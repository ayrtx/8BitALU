module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    //output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    //output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    //output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    //input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  
  sig rst;                  // reset signal
  sig mode;
  sig result[8];
  sig invalid;
  
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    .rst(rst) {
        timeinputname changeState;
        //dff test_case_counter[8];
        dff falufn[6];
        dff fa[8];
        dff fb[8];
        multi_seven_seg seg;
        //fsm state(.clk(clk), #INIT(RESET)) = {RESET, ADD_TEST1, ADD_TEST2, SUB_TEST1, SUB_TEST2, MULT_TEST1, MULT_TEST2, ABS_TEST1, ABS_TEST2, AND_TEST1, AND_TEST2, OR_TEST1, OR_TEST2, XOR_TEST1, XOR_TEST2, A_TEST1, A_TEST2, B_TEST1, B_TEST2, NAND_TEST1, NAND_TEST2, NOR_TEST1, NOR_TEST2, XNOR_TEST1, XNOR_TEST2, CONSTM1_TEST1, CONSTM1_TEST2, CONST0_TEST1, CONST0_TEST2, SHL_TEST1, SHL_TEST2, SHR_TEST1, SHR_TEST2, SRA_TEST1, SRA_TEST2, CMPEQ_TEST1, CMPEQ_TEST2, CMPLT_TEST1, CMPLT_TEST2, CMPLE_TEST1, CMPLE_TEST2, CMPGT_TEST1, CMPGT_TEST2, CMPGE_TEST1, CMPGE_TEST2, ERROR, END};
        fsm state(.clk(clk), #INIT(START)) = {START, TESTING, ERROR};
    }
  }
  
  adder adder;
  zvn zvn;
  mult mult;
  shifter8 shifter;
  compare8 compare;
  boolean boolean;
  bin_to_dec binDec;
  
  always {
  seg.values = {c{1,0,1,0},c{1,0,1,0},c{1,0,1,0},c{1,0,1,0}};
  io_seg = ~seg.seg; // connect segments to the driver
  io_sel = ~seg.sel; // connect digit select to the driver   

      
  reset_cond.in = ~rst_n; // input raw inverted reset signal
  rst = reset_cond.out;   // conditioned reset 
    
  io_led[0] = c{0,0,0,0,0,0,0,0};
  binDec.value = c{0,0,0,0,0,0,0,0};
  
      adder.alufn=io_dip[2][5:0];
      adder.a = io_dip[1];
      adder.b = io_dip[0];
        
      zvn.a = io_dip[1];
      zvn.b = io_dip[0];
      zvn.alufn = io_dip[2][5:0];
      
      mult.a = io_dip[1];
      mult.b = io_dip[0];
      mult.alufn = io_dip[2][5:0];
      
      shifter.alufn=io_dip[2][5:0];
      shifter.a = io_dip[1];
      shifter.b = io_dip[0];
      
      compare.alufn=io_dip[2][5:0];
      compare.z = zvn.z;
      compare.v = zvn.v;
      compare.n = zvn.n;
      
      boolean.alufn=io_dip[2][5:0];
      boolean.a = io_dip[1];
      boolean.b = io_dip[0];
      
      result = 0;
      io_led[0] = 0;
      io_led[1] = 0;

  mode = io_dip[2][7];
  invalid = 0;
      
  case(mode) {
    b0:
      if (state.q == state.START) {
        falufn.d = io_dip[2][5:0];
        fa.d = io_dip[0];
        fb.d = io_dip[1];
      }
      if (state.q == state.TESTING) {
        state.d = state.START;
      }
    b1:
      if (state.q == state.START) {
        falufn.d = b000000;
        fa.d = 0;
        fb.d = 0;
        state.d = state.TESTING;
      }
      
      adder.alufn=falufn.q;
      adder.a = fa.q;
      adder.b = fb.q;
        
      zvn.a = fa.q;
      zvn.b = fb.q;
      zvn.alufn=falufn.q;
      
      mult.a = fa.q;
      mult.b = fb.q;
      mult.alufn=falufn.q;
      
      shifter.alufn=falufn.q;
      shifter.a = fa.q;
      shifter.b = fb.q;
      
      compare.alufn=falufn.q;
      compare.z = zvn.z;
      compare.v = zvn.v;
      compare.n = zvn.n;
      
      boolean.alufn=falufn.q;
      boolean.a = fa.q;
      boolean.b = fb.q;
      
      if (changeState.currentCounter == 26b1 && state.q == state.TESTING) {
        fb.d = fb.q+1;
        if (fb.q == b00000001) {
          fb.d = 0;
          fa.d = fa.q+1;
          if (fa.q == b00000001) {
            fa.d = 0;
            falufn.d = falufn.q+1;
          }
        }
      }
    }
      case(falufn.q){
        b000000: 
          invalid = 0;
          result = adder.sum;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q+fb.q) {
              state.d = state.ERROR;     
          }
        b000001: 
          invalid = 0;
          result = adder.sum;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q-fb.q) {
              state.d = state.ERROR;     
          }
        b000010: 
          invalid = 0;
          result = mult.multiplied;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q*fb.q) {
              state.d = state.ERROR;     
          }
        b000011: 
          invalid = 0;
          result = mult.multiplied;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q*8b1) {
              state.d = state.ERROR;     
          }
        b011000: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q&fb.q) {
              state.d = state.ERROR;  
          }
        b011110: 
          invalid = 0;
          result = boolean.boole;
          //if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q|fb.q) {
             // state.d = state.ERROR;
            //  invalid = 2;}
        b010110: 
          invalid = 0;
          result = boolean.boole + 1;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q^fb.q) {
              state.d = state.ERROR;     
          }
        b011010: 
          invalid = 0;
          result = boolean.boole;
          //if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q) {
             // state.d = state.ERROR;
             // invalid = 2;}
        b011100: 
          invalid = 0;
          result = boolean.boole;
        //  if (mode == b1 && changeState.currentCounter == 26b1 && result != fb.q) {
            //  state.d = state.ERROR;
             // invalid = 2;}
        b010101: 
          invalid = 0;
          result = boolean.boole;
        //  if (mode == b1 && changeState.currentCounter == 26b1 && result != ~(fa.q&fa.q)) {
           //   state.d = state.ERROR;
            //  invalid = 2;}
        b010011: 
          invalid = 0;
          result = boolean.boole;
        //  if (mode == b1 && changeState.currentCounter == 26b1 && result != ~(fb.q&fb.q)) {
            //  state.d = state.ERROR;
            //  invalid = 2;}
        b010111: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != ~(fa.q&fb.q)) {
              state.d = state.ERROR;     
          }
        b010001: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != ~(fa.q|fb.q)) {
              state.d = state.ERROR;     
          }
        b011001: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != ~(fa.q^fb.q)) {
              state.d = state.ERROR;     
          }
        b011111: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != b11111111) {
              state.d = state.ERROR;     
          }
        b010000: 
          invalid = 0;
          result = boolean.boole;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != b00000000) {
              state.d = state.ERROR;    
          }
        b100000: 
          invalid = 0;
          result = shifter.shift;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q<<<fb.q[2:0]) { 
              state.d = state.ERROR;     
          }
        b100001: 
          invalid = 0;
          result = shifter.shift;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != fa.q>>>fb.q[2:0]) {
              state.d = state.ERROR;    
          }
        b100011: 
          invalid = 0;
          result = shifter.shift;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != $signed(fa.q)>>>fb.q[2:0]) {
              state.d = state.ERROR;     
          }
        b110011: 
          invalid = 0;
          result = compare.cmp;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != (fa.q==fb.q)) {
              state.d = state.ERROR;    
          }
        b110101: 
          invalid = 0;
          result = compare.cmp;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != (fa.q<fb.q)) {
              state.d = state.ERROR;     
          }
        b110111: 
          invalid = 0;
          result = compare.cmp;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != (fa.q<=fb.q)) {
              state.d = state.ERROR;     
          }
        b111001: 
          invalid = 0;
          result = compare.cmp;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != (fa.q>fb.q)) {
              state.d = state.ERROR;     
          }
        b111011: 
          invalid = 0;
          result = compare.cmp;
          if (mode == b1 && changeState.currentCounter == 26b1 && result != (fa.q>=fb.q)) {
              state.d = state.ERROR;    
          }
        default:
          result = 0;
          invalid = 1;
        }
      
    led = 0;
    led[5:0] = falufn.q;
    io_led[0] = fa.q;
    io_led[1] = fb.q;
    io_led[2] = result;
    if (result[7] == 1){
      binDec.value = 128 - result[6:0];
      seg.values = {c{1,0,1,1},binDec.digits[2],binDec.digits[1],binDec.digits[0]};
    }
    else{
      binDec.value = result[6:0];
      seg.values = {c{1,0,1,0},binDec.digits[2],binDec.digits[1],binDec.digits[0]};
    }
    if (invalid == 1){
      seg.values = {c{1,0,1,1},c{1,0,1,1},c{1,0,1,1},c{1,0,1,1}};
    }
        
  }
}
